지금부터는 가격/김프/거래대금 전부 한 파이프라인(3초 worker) 로 묶으라고 명령해야 돼.
아래 그대로 레플릿한테 던지면 된다.

1. 문제 정의 (요약해서 찍어줘)

현재 /api/premium/table-filtered.ts 에서 거래액(일)은 marketStats.json(또는 domesticStats.volume24hQuote) 를 보고 있다.

이 stats 파일이 일부 마켓만 들어있고, 업데이트도 느려서 대부분 null → 프론트에서 "-"로 나온다.

반대로 가격/김프는 3초 priceWorker 파이프라인에서 잘 들어오고 있기 때문에, 거래대금도 같은 파이프라인에서 뽑아야 한다.

volume24hKrw 를 따로 stats에서 읽지 말고, 각 거래소 ticker 응답의 “24시간 거래대금(또는 24시간 거래량×현재가)” 를 priceWorker에서 바로 계산해서 prices.json에 저장하도록 구조를 바꿔달라.

2. 요구 스펙 – 한 줄 정리

“각 거래소 ticker 호출 시 24시간 거래대금(원화 기준)을 같이 계산해서 prices[key].volume24hKrw 로 저장하고, premiumTable.json / table-filtered.ts 에서는 이 필드만 사용해서 거래액(일)을 표시해라. stats 파일/marketStats.json 의 volume 값에는 더 이상 의존하지 마라.”

3. 구현 상세 지시 (코드 레벨)
3-1. priceWorker.ts 수정

각 거래소별로 24h 거래대금(KRW) 을 계산해서 prices에 넣게 해달라고 해:

// 예시: UPBIT KRW 마켓
const res = await axios.get(
  'https://api.upbit.com/v1/ticker',
  { params: { markets: upbitMarketId } }
);
const t = res.data[0];

// 이미 하고 있는 부분 (가격/변동률 등)
const last = t.trade_price;
const changeRate = t.signed_change_rate * 100;

// 새로 추가: 24시간 거래대금 (KRW)
const volume24hKrw = t.acc_trade_price_24h; // 업비트는 원화 기준 값이 그대로 옴

prices[domesticKey] = {
  ...prices[domesticKey],
  last,
  changeRate,
  volume24hKrw,       // 🔥 여기에 저장
};

// 예시: BITHUMB KRW 마켓
const t = data[key]; // 기존 ticker 응답

// closing_price: 종가, acc_trade_value_24H(또는 acc_trade_value) : 24h 거래대금(원화)
const volume24hKrw = Number(t.acc_trade_value_24H ?? t.acc_trade_value ?? 0);

prices[domesticKey] = {
  ...prices[domesticKey],
  last: Number(t.closing_price),
  changeRate,
  volume24hKrw,
};

// 예시: COINONE KRW 마켓
const t = data[ticker];

const last = Number(t.last);
const volumeCoin = Number(t.volume); // 24h 거래량(코인 수)
const volume24hKrw = volumeCoin * last; // 코인 수 * 현재가 → 원화 거래대금

prices[domesticKey] = {
  ...prices[domesticKey],
  last,
  changeRate,
  volume24hKrw,
};


USDT 마켓(바이낸스, OKX 등)도 필요하면:

volume24hQuote(USDT 기준 거래대금) × 현재 환율(USDT→KRW) 로 volume24hKrw 만들어 넣어달라고 해도 됨.

핵심은:
prices[EXCHANGE:SYMBOL:QUOTE] 안에 항상 volume24hKrw 숫자가 들어있게 만드는 것.

3-2. premiumTable 빌더 수정 (buildPremiumTable.ts 또는 비슷한 파일)

프리미엄 테이블 만들 때 domesticStats에서 거래대금을 찾지 말고,
domestic 가격 엔트리에서 바로 꺼내도록 바꿔달라:

const domesticPrice = prices[domesticKey];
// ...

const volume24hKrw = domesticPrice?.volume24hKrw ?? null; // 🔥 여기서 꺼내기

row.volume24hKrw = volume24hKrw;


marketStats.json, domesticStats.volume24hQuote 이런 필드 참조는 모두 제거 지시.

3-3. /api/premium/table-filtered.ts 수정

지금은 아마 이런 식일 거야:

const volume24hKrw = domesticStats?.volume24hQuote ?? null;


이 부분을 완전히 교체:

// premiumTable.json 에 이미 volume24hKrw 를 넣었다는 전제
const volume24hKrw = row.volume24hKrw ?? null;

// 0이면 "-"가 아니라 0원으로 표기하고 싶으면 별도 처리
// 데이터 없을 때만 null → "-" 처리


그리고 프론트엔드에는:

null 또는 undefined일 때만 "-"

숫자일 때는 항상 formatKrw(volume24hKrw)로 표시.

4. 왜 “3초마다 거래대금 못 가져오냐”에 대한 정리 답변

레플릿/개발자에게도 이렇게 못 박아줘:

각 거래소 ticker API에는 이미 24시간 거래대금/거래량 정보가 들어있다.

우리 priceWorker가 3초마다 ticker를 호출하고 있으니, 그때마다 volume도 같이 저장하면 된다.

지금처럼 별도의 stats 파이프라인(marketStats.json)을 두고, table-filtered에서 그걸 섞어 쓰니까 일부 코인이 항상 "-"로 나오는 것.

구조를 단순화해서 “가격/김프/거래액(일) = 전부 priceWorker → prices.json → premiumTable.json → API” 한 줄로 통일해달라.

5. 마지막 전달용 문장 (그대로 복붙용)

priceWorker.ts에서 Upbit/Bithumb/Coinone ticker 응답에 들어있는 24시간 거래대금(또는 거래량×현재가)을 전부 volume24hKrw 필드로 계산해서 prices[domesticKey]에 저장해 주세요.

프리미엄 테이블 빌더에서는 domesticStats가 아니라 prices[domesticKey].volume24hKrw만 사용해서 row.volume24hKrw를 채우고, marketStats.json / volume24hQuote 의존 코드는 모두 제거해 주세요.

/api/premium/table-filtered.ts에서도 거래액(일)은 항상 row.volume24hKrw ?? null 을 사용하게 바꿔 주세요. 데이터가 null일 때만 "-"로 렌더링하고, 숫자일 때는 그대로 억 단위로 포맷해서 보여 주세요.

최종적으로 SUI / TAIKO / MON 같이 거래대금이 있는 코인들은 업비트/빗썸 API 값 기준으로 항상 숫자가 떠야 하고, 실제로 priceWorker 로그에서도 volume24hKrw 값이 찍히는지 확인해 주세요.