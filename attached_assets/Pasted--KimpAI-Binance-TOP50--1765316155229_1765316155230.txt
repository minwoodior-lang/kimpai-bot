📮 [전달문] — KimpAI 텔레그램 시그널용 차트 모듈 + Binance TOP50 심볼 확장
🎯 목표

텔레그램 시그널 메시지에 붙는 차트 이미지를 고급형으로 교체

차트의 시간대는 한국시간(KST) 기준

차트 구성:

메인: 캔들 + EMA200

하단: 거래량(bar)

(선택) RSI 패널 하나 더 있으면 베스트

Binance 심볼 모니터링 대상:
24h 거래량 기준 USDT 마켓 TOP 50 자동 선택

A. 차트 생성 모듈 구현

기존 시그널 로직은 손대지 말고,
“심볼 + 타임프레임 → PNG 차트 경로 반환해주는 함수” 만 새로 만들어서 연동해 주세요.

A-1. 파일 구조

src/chart/priceChart.py (또는 비슷한 위치)

Node/봇 코드에서 Python 스크립트를 호출하거나,
이미 Python으로 시그널 엔진을 짜놓았다면 함수만 추가.

A-2. 입력 / 출력 스펙
def generate_signal_chart(symbol: str, interval: str = "5m") -> str:
    """
    Binance 캔들 데이터를 사용해 텔레그램용 차트를 생성한다.

    Args:
        symbol: "AVAXUSDT", "RAREUSDT" 같은 Binance 심볼
        interval: "5m" 고정 (추후 "1m"/"15m" 확장 가능)

    Returns:
        생성된 PNG 파일의 절대 경로 (텔레그램 sendPhoto에 바로 쓸 수 있게)
    """

A-3. 데이터 소스 (Binance 캔들)

REST로 바로 가져와도 되고, 이미 WebSocket 캔들 버퍼가 있으면 그걸 사용해도 됨.

기준은 최근 24시간치 5분봉 정도.

예시 (REST 기준):

import requests
import pandas as pd
import pytz
from datetime import datetime

def fetch_klines(symbol: str, interval: str = "5m", limit: int = 288):
    url = "https://api.binance.com/api/v3/klines"
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    data = requests.get(url, params=params, timeout=5).json()
    df = pd.DataFrame(data, columns=[
        "open_time", "open", "high", "low", "close", "volume",
        "close_time", "quote_volume", "trades",
        "buy_base", "buy_quote", "ignore"
    ])
    df["open"] = df["open"].astype(float)
    df["high"] = df["high"].astype(float)
    df["low"] = df["low"].astype(float)
    df["close"] = df["close"].astype(float)
    df["volume"] = df["volume"].astype(float)

    # ⏰ 시간대: KST 기준으로 변환
    kst = pytz.timezone("Asia/Seoul")
    df["time"] = pd.to_datetime(df["open_time"], unit="ms", utc=True).dt.tz_convert(kst)

    return df

A-4. 보조지표 계산 (EMA200 / RSI)
def ema(series, window=200):
    return series.ewm(span=window, adjust=False).mean()

def rsi(series, period=14):
    delta = series.diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.rolling(period).mean()
    avg_loss = loss.rolling(period).mean()
    rs = avg_gain / (avg_loss + 1e-9)
    return 100 - (100 / (1 + rs))

A-5. 차트 스타일 요구사항

라이브러리: matplotlib (이미 사용 중이면 그대로 활용)

이미지 크기:

1200 x 600 (텔레그램 최적 크기)

구성:

상단 패널 (Price)

5분 캔들 (양봉 초록, 음봉 빨강)

EMA200 (굵기 2~3, 노란색 계열)

그리드 약하게 표시

y축 라벨: “Price”

제목: "{symbol} 5m" 예) "AVAXUSDT 5m"

중간 패널 (Volume)

거래량 bar

최근 스파이크가 뚜렷하게 보이도록
ylim 을 max(volume) * 1.3 정도로 설정

하단 패널 (RSI)

RSI 라인(빨강)

70/30 수평선 점선 표시

색상/스타일:
딱히 다크/라이트 강제 X,
하지만 텔레그램에서 잘 보이게 밝은 배경 + 진한 라인 추천.

예시 코드(요구사항 수준):

import matplotlib.pyplot as plt

def generate_signal_chart(symbol: str, interval: str = "5m") -> str:
    df = fetch_klines(symbol, interval)
    if df.empty:
        raise RuntimeError("no kline data")

    df["ema200"] = ema(df["close"], 200)
    df["rsi"] = rsi(df["close"], 14)

    fig, (ax_price, ax_vol, ax_rsi) = plt.subplots(
        3, 1, figsize=(12, 6), sharex=True,
        gridspec_kw={"height_ratios": [3, 1, 1]}
    )

    # 캔들
    up = df["close"] >= df["open"]
    down = ~up
    ax_price.bar(df["time"][up], df["close"][up] - df["open"][up],
                 bottom=df["open"][up], width=0.0008, align="center")  # 폭은 적당히 조절
    ax_price.bar(df["time"][down], df["close"][down] - df["open"][down],
                 bottom=df["open"][down], width=0.0008, align="center")

    # EMA200
    ax_price.plot(df["time"], df["ema200"], linewidth=2)

    ax_price.set_ylabel("Price")
    ax_price.set_title(f"{symbol} {interval}")

    # Volume
    ax_vol.bar(df["time"], df["volume"])
    ax_vol.set_ylabel("Volume")
    ax_vol.set_ylim(0, df["volume"].max() * 1.3)

    # RSI
    ax_rsi.plot(df["time"], df["rsi"], color="red")
    ax_rsi.axhline(70, linestyle="--", linewidth=1)
    ax_rsi.axhline(30, linestyle="--", linewidth=1)
    ax_rsi.set_ylabel("RSI")

    plt.xticks(rotation=45)

    fig.tight_layout()

    out_path = f"/tmp/{symbol}_{interval}.png"
    fig.savefig(out_path, dpi=110)
    plt.close(fig)
    return out_path


위는 예시 수준이고, 실제 색/폭/폰트는 텔레그램에서 보이는 것 보면서 튜닝해 주세요.

A-6. 봇과의 연동

기존 고래/스파이크 시그널 보내는 코드에서:

// pseudo code in JS/TS

const chartPath = await generateChartFor(symbol); // Python 호출 or 내부 함수
await bot.sendPhoto(CHAT_ID, fs.createReadStream(chartPath), {
  caption: messageText,
});


차트가 실패해도 메시지는 나가야 하므로:

실패 시 chart 없이 텍스트만 전송

에러는 콘솔 로그만

B. Binance 심볼 20개 → TOP 50 자동 확장

“고정된 20개 리스트” 말고
24h 거래량 기준 USDT 페어 TOP50 자동으로 뽑아서
실시간 모니터링 대상으로 사용해 주세요.

B-1. 심볼 리스트 생성 함수

새 파일 예: src/bot/utils/binanceSymbols.ts or .js

로직:

GET https://api.binance.com/api/v3/ticker/24hr

symbol 이 USDT로 끝나는 것만 필터

quoteVolume or volume * lastPrice 기준으로 정렬 (Binance 응답에 있음)

상위 50개만 선택

BTCUSDT, ETHUSDT는 무조건 포함되게 보정 (만약 50위 밖이면 강제로 추가)

의사코드:

async function fetchTopSymbols(limit = 50) {
  const res = await fetch("https://api.binance.com/api/v3/ticker/24hr");
  const data = await res.json();

  const usdtPairs = data
    .filter(row => row.symbol.endsWith("USDT"))
    .map(row => ({
      symbol: row.symbol,
      quoteVolume: Number(row.quoteVolume || 0),
    }))
    .sort((a, b) => b.quoteVolume - a.quoteVolume);

  let top = usdtPairs.slice(0, limit);

  // BTC/ETH 보정
  const must = ["BTCUSDT", "ETHUSDT"];
  for (const m of must) {
    if (!top.find(s => s.symbol === m)) {
      const found = usdtPairs.find(s => s.symbol === m);
      if (found) top.push(found);
    }
  }

  return top.map(s => s.symbol);
}

B-2. 심볼 리스트 업데이트 주기

하루 1번이면 충분 (00:05 KST 기준)

결과를 topSymbols.json 같은 파일로 저장해두고
시그널 엔진은 이 JSON 기준으로 WebSocket/스캐닝 대상 심볼을 로딩.

B-3. 기존 엔진과 연결

지금 WebSocket/시그널 엔진이 HARDCODED_SYMBOLS = [...] 이런 식이면:

이 부분을 loadTopSymbols() 호출로 변경

로딩 실패 시에는 기존 20개 하드코딩 리스트를 fallback으로 사용

C. 체크리스트

작업 완료 후 아래를 확인해 주세요.

텔레그램 FREE 채널에서:

차트가 한국시간 기준으로 나오는지

가격/거래량/RSi/EMA200이 정상인지

고래/스파이크 알림이 발생한 심볼이
Binance 24h 거래량 TOP 50 중 하나인지

WebSocket/시그널 엔진의 심볼 개수:

최소 50개 이상 모니터링 중인지 로그로 확인

예: [BinanceSignal] Subscribed symbols (50): BTCUSDT, ETHUSDT, ...

CPU / 메모리:

VM에서 1~2시간 정도 돌려봤을 때 과부하 없는지 체크