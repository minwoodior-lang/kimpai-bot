ğŸ“¤ Replit ì „ë‹¬ìš© â€“ ì—…ë¹„íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ì˜ˆì‹œ
// scripts/fetchUpbitMarkets.ts
import fs from "fs";
import path from "path";

interface UpbitApiMarket {
  market: string;        // "KRW-BTC"
  korean_name: string;   // "ë¹„íŠ¸ì½”ì¸"
  english_name: string;  // "Bitcoin"
}

interface RawMarket {
  exchange: "UPBIT" | "BITHUMB" | "COINONE";
  market_code: string;
  base_symbol: string;
  quote_symbol: string;
  name_ko?: string;
  name_en?: string;
}

async function fetchUpbitMarkets() {
  const url = "https://api.upbit.com/v1/market/all?isDetails=true";

  const res = await fetch(url, {
    method: "GET",
    headers: {
      Accept: "application/json",
    },
  });

  if (!res.ok) {
    throw new Error(`Upbit API error: ${res.status} ${res.statusText}`);
  }

  const data = (await res.json()) as UpbitApiMarket[];

  if (!Array.isArray(data) || data.length === 0) {
    console.warn("âš  Upbit markets response is empty or invalid");
  }

  // KRW/BTC/USDT ë§ˆì¼“ë§Œ í•„í„°
  const markets = data.filter((m) =>
    m.market.startsWith("KRW-") ||
    m.market.startsWith("BTC-") ||
    m.market.startsWith("USDT-")
  );

  const normalized: RawMarket[] = markets.map((m) => {
    const [quote, base] = m.market.split("-"); // "KRW-BTC" â†’ ["KRW","BTC"]

    return {
      exchange: "UPBIT",
      market_code: m.market,
      base_symbol: base.toUpperCase(),
      quote_symbol: quote.toUpperCase(),
      name_ko: m.korean_name?.trim() || undefined,
      name_en: m.english_name?.trim() || undefined,
    };
  });

  const outPath = path.join("data", "raw", "upbit", "markets.json");
  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, JSON.stringify(normalized, null, 2), "utf-8");

  console.log(`âœ… Upbit markets saved: ${normalized.length} rows`);
}

fetchUpbitMarkets().catch((err) => {
  console.error("âŒ fetchUpbitMarkets failed:", err);
  process.exit(1);
});


ğŸ‘‰ ì´ ìŠ¤í¬ë¦½íŠ¸ ê¸°ì¤€ìœ¼ë¡œ data/raw/upbit/markets.json êµ¬ì¡°ë¥¼ ë§ì¶°ë‘ë©´,
ì•„ë˜ì—ì„œ ì£¼ëŠ” mergeMarkets.tsê°€ ê·¸ëŒ€ë¡œ ì‘ë™í•¨.
ë¹—ì¸/ì½”ì¸ì›ë„ ìœ„ RawMarket ì¸í„°í˜ì´ìŠ¤ì— ë§ê²Œë§Œ ì‚´ì§ ì •ë¦¬í•´ë‹¬ë¼ê³  í•˜ë©´ ë¨.

2ï¸âƒ£ 3ê°œ raw JSON â†’ data/exchange_markets.json ë³‘í•© ìŠ¤í¬ë¦½íŠ¸

ì´ì œ ì§„ì§œ â€œì½”ì¸ ì‹¬ë³¼ í‹€â€ ì—­í• ì„ í•˜ëŠ” ìµœì¢… íŒŒì¼ì„ ë§Œë“œëŠ” ìŠ¤í¬ë¦½íŠ¸.

ğŸ“¤ Replit ì „ë‹¬ìš© â€“ mergeMarkets.ts
// scripts/mergeMarkets.ts
import fs from "fs";
import path from "path";

type ExchangeId = "UPBIT" | "BITHUMB" | "COINONE";

interface RawMarket {
  exchange: ExchangeId;
  market_code: string;
  base_symbol: string;
  quote_symbol: string;
  name_ko?: string;
  name_en?: string;
}

interface ExchangeMarket {
  id: string;           // `${exchange}:${market_code}`
  exchange: ExchangeId;
  market: string;       // market_code ê·¸ëŒ€ë¡œ
  base: string;         // base_symbol
  quote: string;        // quote_symbol
  name_ko?: string;
  name_en?: string;
  isDomestic: boolean;  // ì„¸ ê±°ë˜ì†Œ ëª¨ë‘ true
}

const DOMESTIC_EXCHANGES: ExchangeId[] = ["UPBIT", "BITHUMB", "COINONE"];

function loadRawMarkets(exchange: ExchangeId): RawMarket[] {
  const filePath = path.join(
    "data",
    "raw",
    exchange.toLowerCase(),
    "markets.json"
  );

  if (!fs.existsSync(filePath)) {
    console.warn(`âš  raw markets file not found: ${filePath}`);
    return [];
  }

  const text = fs.readFileSync(filePath, "utf-8");
  if (!text.trim()) return [];

  try {
    const json = JSON.parse(text);
    if (!Array.isArray(json)) {
      console.warn(`âš  raw markets is not array for ${exchange}`);
      return [];
    }
    return json as RawMarket[];
  } catch (e) {
    console.error(`âŒ failed to parse ${filePath}:`, e);
    return [];
  }
}

function main() {
  const upbit = loadRawMarkets("UPBIT");
  const bithumb = loadRawMarkets("BITHUMB");
  const coinone = loadRawMarkets("COINONE");

  const allRaw: RawMarket[] = [...upbit, ...bithumb, ...coinone];

  const map = new Map<string, ExchangeMarket>();

  for (const m of allRaw) {
    if (!m.exchange || !m.market_code || !m.base_symbol || !m.quote_symbol) {
      continue;
    }

    const exchange = m.exchange;
    const market = m.market_code;
    const base = m.base_symbol.toUpperCase();
    const quote = m.quote_symbol.toUpperCase();

    const id = `${exchange}:${market}`;

    // ì¤‘ë³µ ë°©ì§€: ê°™ì€ idê°€ ì´ë¯¸ ìˆìœ¼ë©´ ìŠ¤í‚µ
    if (map.has(id)) continue;

    const isDomestic = DOMESTIC_EXCHANGES.includes(exchange);

    const em: ExchangeMarket = {
      id,
      exchange,
      market,
      base,
      quote,
      // ê°’ì´ ì—†ìœ¼ë©´ í•„ë“œ ìì²´ë¥¼ ìƒëµ
      ...(m.name_ko ? { name_ko: m.name_ko } : {}),
      ...(m.name_en ? { name_en: m.name_en } : {}),
      isDomestic,
    };

    map.set(id, em);
  }

  // ì •ë ¬: exchange â†’ base â†’ quote â†’ market
  const result = Array.from(map.values()).sort((a, b) => {
    if (a.exchange !== b.exchange) {
      return a.exchange.localeCompare(b.exchange);
    }
    if (a.base !== b.base) {
      return a.base.localeCompare(b.base);
    }
    if (a.quote !== b.quote) {
      return a.quote.localeCompare(b.quote);
    }
    return a.market.localeCompare(b.market);
  });

  const outPath = path.join("data", "exchange_markets.json");
  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, JSON.stringify(result, null, 2), "utf-8");

  console.log(
    `âœ… exchange_markets.json saved: ${result.length} markets (UPBIT: ${upbit.length}, BITHUMB: ${bithumb.length}, COINONE: ${coinone.length})`
  );
}

main();

ğŸ‘‰ npm script ì˜ˆì‹œ
// package.json
{
  "scripts": {
    "fetch:upbit": "ts-node scripts/fetchUpbitMarkets.ts",
    "fetch:bithumb": "ts-node scripts/fetchBithumbMarkets.ts",
    "fetch:coinone": "ts-node scripts/fetchCoinoneMarkets.ts",
    "build:markets": "ts-node scripts/mergeMarkets.ts"
  }
}


ì‹¤í–‰ ìˆœì„œ:

npm run fetch:upbit
npm run fetch:bithumb
npm run fetch:coinone
npm run build:markets


ì´ 4ì¤„ê¹Œì§€ ì˜ ëŒì•„ê°€ë©´:

data/raw/*/markets.json 3ê°œ ìƒì„±

data/exchange_markets.json ì™„ì„±
â†’ ì½”ì¸ ì‹¬ë³¼/ë§ˆì¼“ í‹€ êµ¬ì¶• ë.

3ï¸âƒ£ TradingView ì—ëŸ¬ëŠ”?

ì´ê±´ ë§ ê·¸ëŒ€ë¡œ:

ì„¤ì • JSONì€ ì´ë¯¸ ê³ ì³ë‘” ìƒíƒœê³ 

workflow ì¬ë¹Œë“œ + ì„œë²„ ì¬ì‹œì‘ ì´í›„ì— ë‹¤ì‹œ ì½˜ì†” ì°ì–´ë´ì•¼ í•˜ëŠ” ë‹¨ê³„ë¼
ì§€ê¸ˆì€ ì½”ì¸ ë©”íƒ€ / í”„ë¦¬ë¯¸ì—„ ìª½ í‹€ë¶€í„° ë§ˆë¬´ë¦¬í•˜ëŠ” ê²Œ ë§ìŒ.