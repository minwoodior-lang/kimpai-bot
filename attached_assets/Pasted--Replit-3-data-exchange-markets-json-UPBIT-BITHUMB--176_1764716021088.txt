ğŸ“¢ [Replit ì „ë‹¬ìš©] êµ­ë‚´ 3ê±°ë˜ì†Œ ê³µì‹ ì•„ì´ì½˜ ìˆ˜ì§‘ + ë§¤í•‘ ìŠ¤í¬ë¦½íŠ¸
ğŸ¯ ëª©í‘œ

data/exchange_markets.jsonì„ ì½ì–´ì„œ
UPBIT / BITHUMB / COINONE ì˜ base_symbol ëª©ë¡ì„ ìˆ˜ì§‘í•˜ê³ ,

ê° ê±°ë˜ì†Œë³„ ê³µì‹ ì•„ì´ì½˜ URLì—ì„œ ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œ,

/public/icons/{exchange}/{symbol}.png ë¡œ ì €ì¥,

ìµœì¢…ì ìœ¼ë¡œ data/exchangeIcons.json ì—

{
  "UPBIT:BTC": "/icons/UPBIT/BTC.png",
  "BITHUMB:BTC": "/icons/BITHUMB/BTC.png",
  "COINONE:BTC": "/icons/COINONE/BTC.png"
}


í˜•íƒœë¡œ ë§¤í•‘ ìƒì„±.

1) ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ìƒì„±: scripts/fetchDomesticIcons.ts
import fs from "fs";
import path from "path";
import fetch from "node-fetch";

type ExchangeId = "UPBIT" | "BITHUMB" | "COINONE";

interface ExchangeMarket {
  exchange: ExchangeId;
  base: string;   // ex) "BTC"
  // ... ë‚˜ë¨¸ì§€ëŠ” ë¬´ì‹œ
}

interface IconMap {
  [key: string]: string; // "UPBIT:BTC" â†’ "/icons/UPBIT/BTC.png"
}

const EXCHANGE_ICON_BASE: Record<ExchangeId, (symbol: string) => string> = {
  UPBIT: (symbol) =>
    // ì‹¤ì œ ì‚¬ìš©í•˜ëŠ” ì—…ë¹„íŠ¸ ì•„ì´ì½˜ URL íŒ¨í„´ìœ¼ë¡œ êµì²´ í•„ìš”
    // (ì§€ê¸ˆ refreshExchangeMarkets.ts ë‚˜ ê¸°ì¡´ ì•„ì´ì½˜ ìŠ¤í¬ë¦½íŠ¸ì— íŒ¨í„´ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì¬ì‚¬ìš©)
    `<<UPBIT_ICON_URL_FOR_${symbol}>>`,

  BITHUMB: (symbol) =>
    `<<BITHUMB_ICON_URL_FOR_${symbol}>>`,

  COINONE: (symbol) =>
    `<<COINONE_ICON_URL_FOR_${symbol}>>`,
};

const EXCHANGE_DIR_NAME: Record<ExchangeId, string> = {
  UPBIT: "UPBIT",
  BITHUMB: "BITHUMB",
  COINONE: "COINONE",
};

async function downloadIcon(
  exchange: ExchangeId,
  symbol: string
): Promise<string | null> {
  const upper = symbol.toUpperCase();
  const urlBuilder = EXCHANGE_ICON_BASE[exchange];
  const url = urlBuilder(upper);

  try {
    const res = await fetch(url);
    if (!res.ok) {
      console.warn(`âš ï¸ [${exchange}] ${upper} icon fetch failed: ${res.status}`);
      return null;
    }
    const buf = await res.buffer();

    const dir = path.join("public", "icons", EXCHANGE_DIR_NAME[exchange]);
    fs.mkdirSync(dir, { recursive: true });

    const filePath = path.join(dir, `${upper}.png`);
    fs.writeFileSync(filePath, buf);

    // í”„ë¡ íŠ¸ì—ì„œ ì“¸ ìƒëŒ€ ê²½ë¡œ
    const publicPath = `/icons/${EXCHANGE_DIR_NAME[exchange]}/${upper}.png`;
    console.log(`âœ… [${exchange}] ${upper} icon saved â†’ ${publicPath}`);
    return publicPath;
  } catch (e) {
    console.error(`âŒ [${exchange}] ${upper} icon error:`, e);
    return null;
  }
}

function loadExchangeMarkets(): ExchangeMarket[] {
  const file = path.join("data", "exchange_markets.json");
  const text = fs.readFileSync(file, "utf-8");
  const json = JSON.parse(text) as any[];

  // êµ­ë‚´ ê±°ë˜ì†Œë§Œ í•„í„°
  return json
    .filter((m) =>
      ["UPBIT", "BITHUMB", "COINONE"].includes(m.exchange)
    )
    .map((m) => ({
      exchange: m.exchange,
      base: m.base.toUpperCase(),
    }));
}

async function main() {
  const markets = loadExchangeMarkets();

  // ê±°ë˜ì†Œ+ì‹¬ë³¼ ìœ ë‹ˆí¬ ì…‹
  const pairs = new Set<string>();
  for (const m of markets) {
    pairs.add(`${m.exchange}:${m.base}`);
  }

  const iconMap: IconMap = {};

  for (const pair of pairs) {
    const [exchange, symbol] = pair.split(":") as [ExchangeId, string];

    const publicPath = await downloadIcon(exchange, symbol);
    if (publicPath) {
      iconMap[pair] = publicPath;
    }
  }

  const out = path.join("data", "exchangeIcons.json");
  fs.mkdirSync(path.dirname(out), { recursive: true });
  fs.writeFileSync(out, JSON.stringify(iconMap, null, 2), "utf-8");

  console.log(
    `ğŸ§¾ exchangeIcons.json ìƒì„± ì™„ë£Œ: ${Object.keys(iconMap).length} entries`
  );
}

main().catch((e) => {
  console.error("âŒ fetchDomesticIcons failed:", e);
  process.exit(1);
});


âš  ì—¬ê¸°ì„œ <<UPBIT_ICON_URL_FOR_${symbol}>> / <<BITHUMB_ICON_URL_FOR_${symbol}>> / <<COINONE_ICON_URL_FOR_${symbol}>> ë¶€ë¶„ì€
ì§€ê¸ˆ í”„ë¡œì íŠ¸ì—ì„œ ì´ë¯¸ ì“°ê³  ìˆëŠ” â€œê° ê±°ë˜ì†Œ ì½”ì¸ ì•„ì´ì½˜ URL íŒ¨í„´â€ìœ¼ë¡œ êµì²´í•´ë‹¬ë¼ê³  í•´.
(ì´ë¯¸ êµ­ë‚´ ê±°ë˜ì†Œì—ì„œ ì•„ì´ì½˜ ë³´ì—¬ì£¼ë˜ ë¡œì§ì´ ìˆì„ ê±°ë¼ ê·¸ê±° ê·¸ëŒ€ë¡œ ê°€ì ¸ì˜¤ë©´ ë¨)